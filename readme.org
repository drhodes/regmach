* A graphical register machine simulator
** What?
- Of the ilk found in [[https://sarabander.github.io/sicp/html/5_002e1.xhtml#g_t5_002e1_002e2][chapter 5 of SICP.]]
  
** Why?
- It would be neat to be able to mess around with an interactive
  version of the register machines.
- To get experience with rust in the browser.

** How?
- rust, wasm, js for the ui, webgl for the display.

** Plan

*** features
**** schematic entities can be selected/deselected
- uniform vars boolean to fragment shader, i.e. if selectedP then red
  else blue.

***** Modes
****** Lasso - selection mode (at the Display level)
- look into shader effect for this.
- use a translucent box, 
- state machine? 

****** Module Edit
- add terminal to module
- rename terminal
- 


**** simulation (schem level)
- this is later.

**** Devices Types 
- Register
- Stack
  - can stacks be constructed in regmach as linked registers?
- Constant
- Function Blocks
  - Addition
  - Subtraction, going to need to disambiguate on non-commutative
    functions, OR perhaps not => fix the operation order and mandate
    the user FLIP device.  Offer popup help window that displays the
    operation like "A-B".
   
  - Multiplication..
  - Mux?

- Label
- String?, 
- Array?
- List?
- Clock?
- I/O devices
  - LED simulator

**** Meta Register Machines?
What if register machines themselves could be stored in registers?


**** Device Unfolding?
Neat, perhaps at a certain zoom level the underlying implemention is shown mini-map style.

**** Regions
consider distinctly colored backgrounds for each region type.

***** Datapath
where the datapath entities live

***** Controller
where the controller entities live

***** PatchBoard
An interface for wires between datapath and controller. For now
development environment is all schematic and no assembly language, so
having a tidy wire bundle in the middle should keep the rats nest at
bay. TODO: storyboard this in inkscape.




*** look into
- font rendering, https://crates.io/crates/rusttype

- wasm rust
  - https://rustwasm.github.io/wasm-bindgen/examples/webgl.html
  - https://rustwasm.github.io/wasm-bindgen/exbuild/webgl/

*** Get hello triangle opengl running with wasm in the browser.
Ok, combine these two tutorials.
- [[https://github.com/rustwasm/wasm-bindgen/tree/master/examples/without-a-bundler][without-a-bundler]]
- [[https://rustwasm.github.io/wasm-bindgen/exbuild/webgl/][webgl]]


*** Details.
**** KeyboardEvents
Unless the webgl canvas is focused, keyboard events will not be generated.

**** Interpreter Layers
Schematic oversees display.  Display doesn't know anything about
schematic, other than schematic is expecting a stream of events from
the display. Schematic has its own integer based coordinate system
which DISPLAY faithfully snaps devices to.


**** Display
***** disciplines
****** coordinates
Will not use screen coordinates for anything, will immediately project
onto webgl x-y-0 plane, where the schematic lives, and everything will
use webgl coords.

**** Entity Rotations
***** easy option 
compute the rotated meshes, append them to their associated vertex
buffer and store the index of the start of each rotated mesh in a
lookup table. 

So for a triangle mesh T, 
- T_north is the unrotated mesh
- T_west is T_north rotated 90 degrees counter clockwise.
- ...
- T_flip_horizontal
- T_flip_vertical

There are eight possible mesh orientations. Cache all of them with
their bounding boxes.  By the way lyon tesselation has all the
triangles needed for collisions after the spatial hash is checked.

**** Devices have terminals.
**** Devices are entities.
**** Wires are entities.
**** Schematic establishes connections between terminals.

**** Wires 
Need to think about wire/mouse collisions.

***** Types of wires? 
- Datapath wires
- Controller wires
- Cross domain, Controller to Datapath button activation wires.

**** Schematic will share webgl's coordinate system.

**** Camera
***** coordinate transformation
camera can calculate screen-to-world coordinates.  I think it's as
easy as squeezing the display coords down to x∊{-1, 1}, y∊{-1, 1},
then flipping y and multiplying row vec [display_x, display_y, 0, 0]
by the view matrix.

**** vector workflow with lyon and opengl
***** Inkscape 
- draw stuff in inkscape.
- select the target objects
- > Path > Combine
- > Path > Object to Path
- [F2] into node edit mode
- (toolbar) insert new nodes into selected segments
- (toolbar) make selected segments lines

***** Programming
- save the svg out to disk.  At this point, what you're looking for is
  the path string, and it can be found at the bottom of the saved svg.
- use lyon_svg to tesselate the path string (two lines of code).





